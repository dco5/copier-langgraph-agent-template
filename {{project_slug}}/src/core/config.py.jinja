"""
Configuration management with multi-environment support.
Loads settings from environment-specific .env files.
"""

from functools import lru_cache
from pathlib import Path
from typing import Literal

from pydantic import Field, computed_field
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application settings with environment-specific loading."""

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore",
        case_sensitive=False,
    )

    # Application
    app_env: Literal["development", "staging", "production"] = "development"
    project_name: str = "{{ project_name }}"
    debug: bool = False
    api_v1_prefix: str = "/api/v1"

    # Server
    host: str = "0.0.0.0"
    port: int = 8000
    workers: int = 1

{%- if database == 'postgresql' %}
    # Database (PostgreSQL)
    postgres_host: str = "localhost"
    postgres_port: int = 5432
    postgres_db: str = "{{ _db_name }}"
    postgres_user: str = "postgres"
    postgres_password: str = "postgres"

    @computed_field
    @property
    def database_url(self) -> str:
        """Async database URL for SQLAlchemy."""
        return (
            f"postgresql+asyncpg://{self.postgres_user}:{self.postgres_password}"
            f"@{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )

    @computed_field
    @property
    def database_url_sync(self) -> str:
        """Sync database URL for Alembic migrations and checkpointer."""
        return (
            f"postgresql://{self.postgres_user}:{self.postgres_password}"
            f"@{self.postgres_host}:{self.postgres_port}/{self.postgres_db}"
        )
{%- elif database == 'sqlite' %}
    # Database (SQLite)
    sqlite_path: str = "./data/{{ _db_name }}.db"

    @computed_field
    @property
    def database_url(self) -> str:
        """Async database URL for SQLAlchemy."""
        return f"sqlite+aiosqlite:///{self.sqlite_path}"

    @computed_field
    @property
    def database_url_sync(self) -> str:
        """Sync database URL."""
        return f"sqlite:///{self.sqlite_path}"
{%- else %}
    # Database (In-Memory - no persistence)
    # Note: State is lost on restart
{%- endif %}

{%- if llm_provider == 'openai' %}
    # LLM Provider - OpenAI
    openai_api_key: str | None = None
{%- elif llm_provider == 'anthropic' %}
    # LLM Provider - Anthropic
    anthropic_api_key: str | None = None
{%- elif llm_provider == 'azure' %}
    # LLM Provider - Azure OpenAI
    azure_openai_api_key: str | None = None
    azure_openai_endpoint: str | None = None
    azure_openai_api_version: str = "2024-02-01"
{%- elif llm_provider == 'ollama' %}
    # LLM Provider - Ollama (local)
    ollama_base_url: str = "http://localhost:11434"
{%- endif %}

    # LLM Configuration
    default_llm_model: str = "{{ default_model }}"
    default_llm_temperature: float = 0.7
    max_tokens: int = 4096
    llm_request_timeout: int = 60
    llm_max_retries: int = 3

{%- if use_semantic_memory and database == 'postgresql' %}
    # Memory Configuration
    long_term_memory_enabled: bool = True
    memory_collection_name: str = "{{ _memory_collection }}"
    memory_model: str = "{% if llm_provider == 'openai' %}gpt-4.1-mini{% elif llm_provider == 'anthropic' %}claude-haiku-4-5-20251001{% else %}{{ default_model }}{% endif %}"
    memory_embedder_model: str = "text-embedding-3-small"
{%- endif %}

{%- if observability == 'langfuse' %}
    # Observability - Langfuse
    langfuse_enabled: bool = True
    langfuse_public_key: str | None = None
    langfuse_secret_key: str | None = None
    langfuse_host: str = "https://cloud.langfuse.com"
{%- elif observability == 'langsmith' %}
    # Observability - LangSmith
    langsmith_enabled: bool = True
    langsmith_api_key: str | None = None
    langsmith_project: str = "{{ project_slug }}"
{%- endif %}

{%- if use_auth %}
    # Security
    secret_key: str = "change-me-in-production-use-openssl-rand-hex-32"
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    refresh_token_expire_days: int = 7
{%- endif %}

{%- if use_rate_limiting %}
    # Rate Limiting
    rate_limit_enabled: bool = True
    rate_limit_requests: int = 100
    rate_limit_period: int = 60  # seconds
{%- endif %}

{%- if use_prometheus %}
    # Metrics
    metrics_enabled: bool = True
{%- endif %}

    @computed_field
    @property
    def is_development(self) -> bool:
        return self.app_env == "development"

    @computed_field
    @property
    def is_production(self) -> bool:
        return self.app_env == "production"


def get_env_file() -> str:
    """Determine which .env file to load based on APP_ENV."""
    import os

    app_env = os.getenv("APP_ENV", "development")
    env_file = f".env.{app_env}"

    # Fall back to .env if environment-specific file doesn't exist
    if not Path(env_file).exists():
        env_file = ".env"

    return env_file


@lru_cache
def get_settings() -> Settings:
    """Get cached settings instance."""
    env_file = get_env_file()
    return Settings(_env_file=env_file)


# Convenience export
settings = get_settings()
